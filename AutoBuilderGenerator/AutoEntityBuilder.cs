using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

namespace AutoBuilderGenerator;

[Generator]
public class AutoEntityBuilder : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            (node, _) => node is ClassDeclarationSyntax t && t.AttributeLists.Any(x => x.Attributes.Any(a => a.Name.ToString() == "AutoBuilder")),
            (syntaxContext, _) => (ClassDeclarationSyntax)syntaxContext.Node
        ).Where(x => x is not null);
        
        var compilation = context.CompilationProvider
                                 .Combine(provider.Collect());
        
        context.RegisterSourceOutput(compilation, Execute);
    }
    private void Execute(SourceProductionContext context, (Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes) tuple)
    {
        var (compilation, classes) = tuple;
        
        foreach (var syntax in classes)
        {
            var symbol = compilation.GetSemanticModel(syntax.SyntaxTree)
                                    .GetDeclaredSymbol(syntax) as INamedTypeSymbol;

            // get the namespace of the current syntax
            var syntaxParent = syntax.Parent;
            string @namespace = string.Empty;
            if (syntaxParent is BaseNamespaceDeclarationSyntax namespaceDeclaration)
            {
                @namespace = namespaceDeclaration.Name.ToString();
            }

            var properties = symbol!.GetMembers()
                                    .OfType<IPropertySymbol>()
                                    .Where(x => x.SetMethod is not null);
            
            string prefixCode = $$"""
                          // <auto-generated />
                          namespace {{@namespace}};
                          
                          public class {{symbol!.Name}}Builder
                          {
                            protected {{symbol!.Name}} {{symbol!.Name}};
                            public static implicit operator {{symbol!.Name}}({{symbol!.Name}}Builder builder)
                            {
                                return builder.{{symbol!.Name}};
                            }
                            
                            public {{symbol!.Name}}Builder()
                            {
                                {{symbol!.Name}} = new {{symbol!.Name}}();
                            }
                            
                            public {{symbol!.Name}}Builder({{symbol!.Name}} {{symbol!.Name.ToLower()}})
                            {
                                this.{{symbol!.Name}} = {{symbol!.Name.ToLower()}};
                            }
                          """;
            
            
            
            string suffixCode = """
                          }
                          """;

            StringBuilder codeBuilder = new StringBuilder();
            
            codeBuilder.AppendLine(prefixCode);
            
            foreach (var property in properties)
            {
                // check if property has AutoBuilderIgnore as attribute
                var ignoreAttribute = property.GetAttributes()
                                           .Any(x => x.AttributeClass?.Name == "AutoBuilderIgnoreAttribute");
                
                if (ignoreAttribute)
                {
                    continue;
                }

                // check if property type is a AutoBuilder attribute, then add a propfull attribute to this builder
                var autoBuilderAttribute = property.Type.GetAttributes()
                                                  .Any(x => x.AttributeClass?.Name == "AutoBuilderAttribute");

                if (autoBuilderAttribute)
                {
                    codeBuilder.AppendLine($"    private {property.Type}Builder _{property.Name.ToLower()};");
                    
                    codeBuilder.AppendLine($"    public {property.Type}Builder {property.Name} {{ get {{ return _{property.Name.ToLower()} ??= new {property.Type}Builder({symbol!.Name}.{property.Name}); }} }}");
                    continue;
                }
                
                codeBuilder.AppendLine("// " + autoBuilderAttribute);
                // check if property is a List, then add a method to add items to the list
                if (property.Type.ToString().StartsWith("System.Collections.Generic.List<"))
                {
                    var listType = property.Type.ToString().Replace("System.Collections.Generic.List<", "").Replace(">", "");
                    codeBuilder.AppendLine($@"    public {symbol!.Name}Builder Add{property.Name}(params {listType}[] {property.Name.ToLower()})");
                    codeBuilder.AppendLine("    {");
                    codeBuilder.AppendLine($@"        {symbol!.Name}.{property.Name}.AddRange({property.Name.ToLower()}.ToList());");
                    codeBuilder.AppendLine("        return this;");
                    codeBuilder.AppendLine("    }");
                    codeBuilder.AppendLine();
                }
                else
                {
                    codeBuilder.AppendLine($@"    public {symbol!.Name}Builder With{property.Name}({property.Type} {property.Name.ToLower()})");
                    codeBuilder.AppendLine("    {");
                    codeBuilder.AppendLine($@"        {symbol!.Name}.{property.Name} = {property.Name.ToLower()};");
                    codeBuilder.AppendLine("        return this;");
                    codeBuilder.AppendLine("    }");
                    codeBuilder.AppendLine();
                }
            }

            codeBuilder.AppendLine(suffixCode);
            
            context.AddSource($"{symbol!.Name}Builder.g.cs", codeBuilder.ToString());
        }
    }
}
